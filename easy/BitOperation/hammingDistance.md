# 461. 汉明距离

### 原题
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：
0 ≤ x, y < 2^31.

示例:
输入: x = 1, y = 4
输出: 2
解释:

```
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
```

上面的箭头指出了对应二进制位不同的位置。

来源：力扣（LeetCode）
[链接](https://leetcode-cn.com/problems/hamming-distance)：https://leetcode-cn.com/problems/hamming-distance

###  两种解法

**先看这！！**这个题只是稍微比 [191.只出现一次的数字](https://github.com/ustcyyw/yyw_algorithm/blob/master/easy/BitOperation/hammingWeight.md)多了一点东西，其实两种解法都可以直接借鉴一下，然后就很简单了。

##### 1.移位操作

```java
public int hammingDistance(int x, int y) {
        int count = 0;
        while(y != 0 || x != 0){ // 直到移位使得都为0，那么更高位均为0，是相等的就不用去统计了。
            if((y & 1) != (x & 1)) // 除了当前位，一定都变0（和0进行与运算），当前位则保留（和1进行与运算）
                count++;
            y >>= 1; // 右移动一位
            x >>= 1;
        }
        return count;
    }
```

思路分析：

* 求两个数中二进制不同的的位置的数目，本质上还是需要知道两个数每一位是0还是1，如果不相等就`count++`。不断获得每一位是0还是1参考191题。这里注意一下循环条件，当某个数被移动为0后，另外一个数不为0的话，还有不相等的位置没有统计完成。所以循环条件为`y != 0 || x != 0`。
* 时间复杂度：$O(1)$ 。运行时间依赖于数字x,y的位数。由于这题中 x,y 都是 32 位数。空间复杂度是$O(1)$的。

运行结果：
* 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户
* 内存消耗 :36.3 MB, 在所有 Java 提交中击败了5.05%的用户

##### 异或的使用

```java
private int hammingDistance2(int x, int y) {
        int n = x ^ y;
        int count = 0;
        while (n != 0) {
            count++;
            n = n & (n - 1);
        }
        return count;
    }
```

思路分析：

* 求两个数中二进制不同的位置的数量。异或正好是相同为0，不同为1。如果我们将两个数先进行异或，那么相同的位都变成0，不同的位都是1，只需要统计异或的结果的二进制表示中有多少个1即可。成为了191题。
* 运用一个常用技巧，任何数 x在进行了 x & (x - 1)后都将其二进制表示的最低一位1变成了。统计一个数的二进制表示中有多少个1，就去计算进行多少次 n & (n - 1)后（别忘了赋值），n变为0即可。
* 时间复杂度：$O(1)$ 。运行时间依赖于数字`int n = x ^ y`中1的位数，至多进行32次操作。空间复杂度是$O(1)$的。

运行结果：

* 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户
* 内存消耗 :36.3 MB, 在所有 Java 提交中击败了5.05%的用户