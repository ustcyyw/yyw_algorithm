# 5377. 将二进制表示减到 1 的步骤数

### 183周周赛第二题 medium
给你一个以二进制形式表示的数字 s 。请你返回按下述规则将其减少到 1 所需要的步骤数：
如果当前数字为偶数，则将其除以 2 。
如果当前数字为奇数，则将其加上 1 。
题目保证你总是可以按上述规则将测试用例变为 1 。

示例 1：
输入：s = "1101"
输出：6
解释："1101" 表示十进制数 13 。
Step 1) 13 是奇数，加 1 得到 14 
Step 2) 14 是偶数，除 2 得到 7
Step 3) 7  是奇数，加 1 得到 8
Step 4) 8  是偶数，除 2 得到 4  
Step 5) 4  是偶数，除 2 得到 2 
Step 6) 2  是偶数，除 2 得到 1  

示例 2：
输入：s = "10"
输出：1
解释："10" 表示十进制数 2 。
Step 1) 2 是偶数，除 2 得到 1 

示例 3：
输入：s = "1"
输出：0

提示：

`1 <= s.length <= 500`
s 由字符 '0' 或 '1' 组成。
s[0] == '1'

来源：力扣（LeetCode）
[链接](https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one)：https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one

### 解法

```java
public int numSteps(String s) {
        char[] num = s.toCharArray();
        int count = 0;
        for(int i = num.length - 1; i >= 0; i--){
            if(i == 0 && num[i] == '1')
                return count;
            if(num[i] == '1'){
                count++;
                for(int j = i - 1; j >= 0; j--){
                    if(num[j] == '0'){
                        num[j] = '1';
                        break;
                    } else {
                        num[j] = '0';
                    }
                }
            }
            count++;
        }
        return count;
    }
```

思路分析：

* 看起来只需要将二进制字符串表示为数字，然后按要求循环计数就可以。但是题目中字符串的长度最大为500。那么java中的基本数据类型long也就64位，所以这样肯定行不通了。
* 从数字的二进制表示入手：
    * 如果一个数奇数，那么二进制位表示的最低一位肯定是1。对于奇数要将其加1，二进制的加1就需要一直向左将每一个1变为0，直到某一位是0，将0变为1（完成进位操作真累）
    * 如果一个数是偶数，那么二进制位表示的最低一位肯定是0。对于偶数除以2，相当于将有符号右移一位。
* 题目中给定的字符串已经是二进制表示，为了方便用字符数组来存放这些信息`char[] num = s.toCharArray();`，使用变量`count`来计数。
* 从二进制的低位开始进行操作，所以表示当前最低位的`i`初始化为`num.length - 1`，`i--`表示最低位变成了之前的倒数第二位，也就是该数进行除以2的操作。所以每一次`i--`都代表了偶数除以2的操作，所以循环的每一次都要进行`count++`
* 遇到当前最低位`num[i] == '1'`的情况，要进行奇数+1的操作，将`count++`，然后向前文描述的那样进行进位操作（一个内循环while）
* 注意！！！还有一个坑人的地方😡我在这bug了很久。
    * 如果没有因为进位操作将最高位变为0，那么当for循环进行到最高位的时候，如果不进行特殊处理，就会先进行奇数+1再进行偶数除以2，比正确答案操作多了两步。
    * 如果没有因为进位操作将最高位变为0，其实`i == 0`时，这个数已经是1了。所以当`i == 0 && num[i] == '1'`，直接返回`count`就可以了。
    * 如果因为进位操作将最高位变为0，最终进位到更高位的1没有在字符数组中表示，所以循环结束再返回刚好符合题意，最后剩的就是那个没有表示在字符数组中的最后一个1。
* 时间复杂度为$O(n)$，空间复杂度为$O(1)$。

运行结果：

* 1 ms