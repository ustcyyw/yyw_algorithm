# 75.颜色分类

### 原题
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:
不能使用代码库中的排序函数来解决这道题。

示例:
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]

进阶：
一个直观的解决方案是使用计数排序的两趟扫描算法。
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
你能想出一个仅使用常数空间的一趟扫描算法吗？

来源：力扣（LeetCode）
[链接](https://leetcode-cn.com/problems/sort-colors)：https://leetcode-cn.com/problems/sort-colors

### 解法：快速排序中的三向切分

```java
public void sortColors(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 1){
                exch(nums, i, 0);
                break;
            }
        }
        int gt = nums.length - 1, lt = 0, i = 1;
        while(gt >= i){
            if(nums[i] > 1) exch(nums, gt--, i);
            else if (nums[i] < 1) exch(nums, lt++, i++);
            else i++;
        }
    }

    private void exch(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```

思路分析：

* 跳过描述看输入输出，其实就是将只有三个元素0,1,2的数组进行排序。
* 排序数组的几种方式中，有一个针对有大量重复元素的方法：三向切分的快速排序。每一次三向切分都会将数组分为三个部分，左边部分比切分点小，中间部分和切分点相等，右边部分比切分点大。
* 所以，本题刚好只有三个元素，那么我们选择1这个元素做为切分点，进行一次三向切分，就能得到结果。时间复杂度为$O(n)$，这是一个原地排序算法，所以空间复杂度为$O(1)$。
* 三向切分最重要的是四个区间（索引对应的区间），定要好四个区间的边界（以下都是闭区间），就很容易完成：
    * 比切分点小的元素`[lo, lt - 1]`
    * 比与切分点相等的元素`[lt, i - 1]`
    * 还没有确定大小的区间`[i, gt]`
    * 比切分点大的区间`[gt + 1, hi]`
* 先找到第一个1，然后将他交换到数组索引为0处，做为切分元素。对照刚才说的区间边界，比切分点小的元素，在初状态不存在，所以`lt = 0`，这样就可以使得区间`[0, lt - 1]`不存在；同理`gt = nums.length - 1`。与切分点相等的元素就是索引为0的元素，`i = 1`就使得区间`[lt, i - 1]`就是区间`[0, 0]`。

代码解释：

* 第9行，循环条件为`gt >= i`，因为这个条件使得没有确定大小的区间`[i, gt]`中还有元素。
* 第10行`if(nums[i] > 1) exch(nums, gt--, i)`，`i`这个元素大于切分点，与索引`gt`的元素交换，交换后`i`这个索引的元素还是没有确定的，但是`gt`那个元素大于切分点，根据区间的定义，需要`gt++`。同理11，12行也通过区间的定义可以得到。

运行结果：
* 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户
* 内存消耗 :38.5 MB, 在所有 Java 提交中击败了5.02%的用户